

name: ECR build multi platform and push script
on:
  workflow_call:
    inputs:
      image_name:
        description: The name the docker image. This is also the name of the ECR repository
        type: string
        required: true
      image_tag:
        description: The tag where the image will be tagged with.
        type: string
        required: true
      dockerfile:
        description: Relative dockerfile to the docker file seen from the repository root. No leading slahs.
        type: string
        required: true
      dockerfile_context:
        description: Context to build the docker image. By default this is the root of the repo (empty string). No trailing or leading slash should be added
        type: string
        default: ""
      platforms:
        description: Comma separated list of platforms, for example linux/amd64,linux/arm64 or linux/amd64, or linux/arm64
        type: string
        default: linux/amd64,linux/arm64
      aws_region:
        description: AWS region where the container registry is
        type: string
        default: eu-west-1
      push_images:
        description: When this is set to 0, images will not be pushed only a test run is done
        type: string
        default: 1
      pull_first:
        description: Docker images you need to pull first
        type: string
        default:
        required: false
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
        description: AWS access key id
      AWS_SECRET_ACCESS_KEY:
        required: true
        description: AWS access ket secret
      COMPOSER_AUTH:
        required: false
        description: The token to authenticate on github
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # Get rid of windows line ends
      - name: Configure git to clear carriage returns
        run: git config --global core.autocrlf input
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout the repository
        uses: actions/checkout@v3
      # Setup QEMO
      - name: Set up QEMU, required for buildx
        uses: docker/setup-qemu-action@v3
      # Setup docker buildx
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v3
      # Login to AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}
      # Login to ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      # Build the images
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ inputs.image_name }}
          IMAGE_TAG: ${{ inputs.image_tag }}
          COMPOSER_AUTH: ${{ secrets.COMPOSER_AUTH }}
        run: |
          echo "This step will build a multi platform image ${ECR_REPOSITORY}:${IMAGE_TAG} for platforms: ${{inputs.platforms}}"
          
          # Pull required images
          if [[ -n "${{inputs.pull_first}}" ]]; then
            echo 
            echo "## Pulling required images ##"

            for image in "${{inputs.pull_first}}"; do
                echo "Pull ${ECR_REGISTRY}/${image}}"
                docker pull "${ECR_REGISTRY}/${image}"
                echo "Tag ${ECR_REGISTRY}/${image} as ${image}"
                docker tag "${ECR_REGISTRY}/${image}" "${image}"
            done;

            echo "List docker images:"
            docker images
            echo 
          fi
          
          echo
          echo "List docker buildx environment"
          docker buildx ls
          docker buildx use default
          
          # Find full path to docker context
          if [[ -z "${{inputs.dockerfile_context}}" ]]; then
            dockerfile_context="$GITHUB_WORKSPACE"
          else
            dockerfile_context="$GITHUB_WORKSPACE/${{inputs.dockerfile_context}}"
          fi;
          
          date_tag="$(date "+%Y%m%d.%H%M")"
            
          # Create all tags
          tags_space_separated=""
          tags_command=""
        
          # Tags passed and one added with the timestamp
          for tag in ${IMAGE_TAG}
          do
            # In the commmand
            tags_command="${tags_command} -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${tag} -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${tag}-${date_tag}"
        
            # Readable output
            tags_space_separated="${tags_space_separated} ${ECR_REPOSITORY}:${tag} ${ECR_REPOSITORY}:${date_tag}-${tag}"
          done
        
          # Construct command
          command="docker buildx build --build-arg COMPOSER_AUTH --push ${tags_command} --platform "${platforms}" -f "${GITHUB_WORKSPACE}/${{inputs.dockerfile}}" "${dockerfile_context}""

          # Output what the plan is
          echo 
          echo "## Build ${ECR_REPOSITORY}:${IMAGE_TAG} ##"
          echo "Tags: ${tags_space_separated}"
          echo "Dockerfile: ${{inputs.dockerfile}}"
          echo "Context ${dockerfile_context}"
          echo "Platforms: ${platforms}"
        
          if [[ "${{inputs.push_images}}" == "1" ]]; then
            # Build
            echo "Dry run: No";
            echo "Running ${command}";
            ${command};
          else
            echo "Dry run: Yes";
            echo "Command ${command}";
          fi

